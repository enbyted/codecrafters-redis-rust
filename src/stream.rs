use std::{
    collections::{BTreeMap, HashMap},
    num::{ParseIntError, TryFromIntError},
    ops::Bound,
    time::{SystemTime, SystemTimeError, UNIX_EPOCH},
};

use thiserror::Error;

#[derive(Debug, Clone, Error, PartialEq)]
#[non_exhaustive]
pub enum ItemIdParseError {
    #[error("The item id is missing the '-' separator")]
    MissingDash,
    #[error("The item id has too many '-' separators - only one is allowed")]
    TooManyDashes,
    #[error("'{0} is not a valid number for item id")]
    NotANumber(String, #[source] ParseIntError),
}

#[derive(Debug, Clone, Error)]
#[non_exhaustive]
pub enum InsertionError {
    #[error("New entry has to have ID higher than the latest one ")]
    IdIsNotGreaterThanHighestStored(ItemId),

    #[error("Failed to get system time")]
    FailedToGetTime(#[from] SystemTimeError),

    #[error("Unexpected integer overflow")]
    IntegerOverflow(#[from] TryFromIntError),

    #[error("Item ID must be greater than 0-0")]
    IdTooLow,
}

impl PartialEq for InsertionError {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (
                Self::IdIsNotGreaterThanHighestStored(l0),
                Self::IdIsNotGreaterThanHighestStored(r0),
            ) => l0 == r0,
            (Self::FailedToGetTime(_), Self::FailedToGetTime(_)) => true,
            (Self::IntegerOverflow(_), Self::IntegerOverflow(_)) => true,
            _ => false,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ProvidedItemId {
    AutoGenerated,
    AutoSequence(u64),
    ExplicitId(ItemId),
}

impl TryFrom<&str> for ProvidedItemId {
    type Error = ItemIdParseError;

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        if value == "*" {
            return Ok(Self::AutoGenerated);
        }

        let mut parts = value.split('-');
        let timestamp = parts
            .next()
            .expect(".split() always returns at least one item");
        let counter = parts.next().ok_or(ItemIdParseError::MissingDash)?;
        if !parts.next().is_none() {
            return Err(ItemIdParseError::TooManyDashes);
        }

        let timestamp = timestamp
            .parse()
            .map_err(|err| ItemIdParseError::NotANumber(timestamp.to_string(), err))?;

        if counter == "*" {
            Ok(Self::AutoSequence(timestamp))
        } else {
            let counter = counter
                .parse()
                .map_err(|err| ItemIdParseError::NotANumber(counter.to_string(), err))?;

            Ok(Self::ExplicitId((timestamp, counter).try_into()?))
        }
    }
}

impl From<ItemId> for ProvidedItemId {
    fn from(value: ItemId) -> Self {
        Self::ExplicitId(value)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ItemId(u64, u64);

impl ItemId {
    fn next(&self) -> Self {
        Self(self.0, self.1 + 1)
    }
}

impl std::fmt::Display for ItemId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}-{}", self.0, self.1)
    }
}

impl TryFrom<(u64, u64)> for ItemId {
    type Error = ItemIdParseError;

    fn try_from(value: (u64, u64)) -> Result<Self, Self::Error> {
        Ok(Self(value.0, value.1))
    }
}

impl TryFrom<&str> for ItemId {
    type Error = ItemIdParseError;

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        let mut parts = value.split('-');
        let timestamp = parts
            .next()
            .expect(".split() always returns at least one item");
        let counter = parts.next().ok_or(ItemIdParseError::MissingDash)?;
        if !parts.next().is_none() {
            return Err(ItemIdParseError::TooManyDashes);
        }

        let timestamp = timestamp
            .parse()
            .map_err(|err| ItemIdParseError::NotANumber(timestamp.to_string(), err))?;
        let counter = counter
            .parse()
            .map_err(|err| ItemIdParseError::NotANumber(counter.to_string(), err))?;

        (timestamp, counter).try_into()
    }
}

pub type ItemData = HashMap<String, String>;

#[derive(Debug, Clone, PartialEq)]
pub struct Item<'a> {
    pub(crate) id: ItemId,
    pub(crate) elements: &'a ItemData,
}

#[derive(Debug, Clone)]
pub struct Stream {
    items: BTreeMap<ItemId, ItemData>,
}

impl Stream {
    pub fn new() -> Self {
        Stream {
            items: BTreeMap::new(),
        }
    }

    pub fn insert(&mut self, id: ProvidedItemId, data: ItemData) -> Result<ItemId, InsertionError> {
        let id = match id {
            ProvidedItemId::AutoGenerated => {
                let now_ms: u64 = SystemTime::now()
                    .duration_since(UNIX_EPOCH)?
                    .as_millis()
                    .try_into()?;

                if let Some((last_key, _)) = self.items.last_key_value() {
                    if last_key.0 >= now_ms {
                        last_key.next()
                    } else {
                        ItemId(now_ms, 0)
                    }
                } else {
                    ItemId(now_ms, 0)
                }
            }
            ProvidedItemId::AutoSequence(timestamp) => {
                if let Some((last_key, _)) = self.items.last_key_value() {
                    if last_key.0 > timestamp {
                        return Err(InsertionError::IdIsNotGreaterThanHighestStored(*last_key));
                    }

                    if last_key.0 == timestamp {
                        last_key.next()
                    } else {
                        ItemId(timestamp, 0)
                    }
                } else {
                    ItemId(timestamp, if timestamp == 0 { 1 } else { 0 })
                }
            }
            ProvidedItemId::ExplicitId(id) => {
                if id == ItemId(0, 0) {
                    return Err(InsertionError::IdTooLow);
                }
                if let Some((last_key, _)) = self.items.last_key_value() {
                    if last_key >= &id {
                        return Err(InsertionError::IdIsNotGreaterThanHighestStored(*last_key));
                    }
                }
                id
            }
        };

        self.items.insert(id, data);

        Ok(id)
    }

    pub fn range(
        &self,
        start: Bound<ItemId>,
        end: Bound<ItemId>,
    ) -> impl Iterator<Item = Item<'_>> {
        let range = self.items.range((start, end));

        range.map(|(id, elements)| Item { id: *id, elements })
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn parse_item_ids() {
        assert_eq!(ItemId::try_from("0-1"), Ok(ItemId(0, 1)));
        assert_eq!(ItemId::try_from("999-0"), Ok(ItemId(999, 0)));
        assert_eq!(ItemId::try_from("0-0"), Ok(ItemId(0, 0)));
        assert!(ItemId::try_from("-1").is_err());
        assert!(ItemId::try_from("0-1-").is_err());
    }

    #[test]
    fn insertion_of_0_0() {
        let mut sut = Stream::new();

        assert!(sut
            .insert("0-0".try_into().unwrap(), ItemData::new())
            .is_err());
    }

    #[test]
    fn id_generation_zero_ts() {
        let mut sut = Stream::new();

        assert_eq!(
            sut.insert("0-*".try_into().unwrap(), ItemData::new()),
            Ok("0-1".try_into().unwrap())
        );
    }

    #[test]
    fn id_generation() {
        let mut sut = Stream::new();

        assert_eq!(
            sut.insert("2-*".try_into().unwrap(), ItemData::new()),
            Ok("2-0".try_into().unwrap())
        );

        assert_eq!(
            sut.insert("2-*".try_into().unwrap(), ItemData::new()),
            Ok("2-1".try_into().unwrap())
        );

        assert_eq!(
            sut.insert("3-*".try_into().unwrap(), ItemData::new()),
            Ok("3-0".try_into().unwrap())
        );

        assert_eq!(
            sut.insert("3-*".try_into().unwrap(), ItemData::new()),
            Ok("3-1".try_into().unwrap())
        );

        assert_eq!(
            sut.insert("2-*".try_into().unwrap(), ItemData::new()),
            Err(InsertionError::IdIsNotGreaterThanHighestStored(ItemId(
                3, 1
            )))
        );
    }
}
